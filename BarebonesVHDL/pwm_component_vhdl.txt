-- new_component.vhd

-- This file was auto-generated as a prototype implementation of a module
-- created in component editor.  It ties off all outputs to ground and
-- ignores all inputs.  It needs to be edited to make it do something
-- useful.
-- 
-- This file will not be automatically regenerated.  You should check it in
-- to your version control system if you want to keep it.

-- references 'servo_pwm.vhd from G4_2015w_pwm app notes and Tutorial2 from w2018. 

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity new_component is
	port (
		en_a      : out std_logic;                                        --  conduit_end.en_a
		en_b      : out std_logic;                                        --             .en_b
		a         : out std_logic;                                        --             .a
		b         : out std_logic;                                        --             .b
		a_comp    : out std_logic;                                        --             .a_comp
		b_comp    : out std_logic;                                        --             .b_comp
		write_n   : in  std_logic                     := '0';             -- avalon_slave.write_n
		writedata : in  std_logic_vector(31 downto 0) := (others => '0'); --             .writedata
		read_n    : in  std_logic                     := '0';             --             .read_n
		readdata  : out std_logic_vector(31 downto 0);                    --             .readdata
		reset_n   : in  std_logic                     := '0';             --        reset.reset_n
		clk       : in  std_logic                     := '0'              --        clock.clk
	);
end entity new_component;

architecture rtl of new_component is
	procedure get_step (	-- A(Brown) A#(Red) B(Green) B#(White) 

	signal current : in std_logic_vector(1 downto 0);
	
	constant fs_one : std_logic_vector (3 downto 0)     := b"1010";
	constant fs_two : std_logic_vector (3 downto 0)     := b"1001";
	constant fs_three : std_logic_vector (3 downto 0)   := b"0101";
	constant fs_four : std_logic_vector (3 downto 0)    := b"0110";	
		
	signal four_coils : out std_logic_vector (3 downto 0) 
	) is
		begin
		
		case current is
			when b"00" => four_coils <= fs_one;
			when b"01" => four_coils <= fs_two;
			when b"10" => four_coils <= fs_three;
			when b"11" => four_coils <= fs_four;
		end case;
		
	end get_step;
	
	
	
	signal curr :  std_logic_vector(1 downto 0) := "00";
	
	signal required : std_logic_vector(15 downto 0) := (others => '0'); -- integer is 2 bytes or 16 bits 
	
	signal output_coils : std_logic_vector(3 downto 0) ;
	
	
begin
	write_to_hBridge:
		process(clk, reset_n,write_n) is
		
			-- 1600Hz or 1600PPS for 0.7kg load (75.68mHm) at FULL STEP 
			variable numPeriodsToDo: integer := 31250; 
			variable numPulsesToDo: integer:= 28125; -- 90% duty cycle

		begin
		
			if(reset_n = '0') then
				readdata <= "00000000000000000000000000000000";
				
				-- hard brake? 
				en_a <= '0';
				en_b <= '0';
				
			elsif(write_n = '0') then
				required <= writedata(15 downto 0); -- last half of writedata is required pulses
				
				
			elsif rising_edge(clk)  and (required /= "0000000000000000") then
			
			--	while (required /= "0000000000000000") loop
					--rising edge
					if(numPeriodsToDo = 31250) and (numPulsesToDo = 28125) then
						numPeriodsToDo := numPeriodsToDo - 1;
						numPulsesToDo := numPulsesToDo - 1;
						
						get_step(curr, four_coils => output_coils ); 
					
						a <= output_coils(3);
						a_comp <= output_coils(2);
						b <= output_coils(1);
						b_comp <= output_coils(0);
						
					
					--pull high
					elsif(numPeriodsToDo > 0) and (numPulsesToDo > 0) then
						numPeriodsToDo := numPeriodsToDo - 1;
						numPulsesToDo := numPulsesToDo - 1;
						
						en_a <= '1';
						en_b <= '1';
					
					--falling edge
					elsif(numPeriodsToDo = 3125) and (numPulsesToDo = 0) then
						numPeriodsToDo := numPeriodsToDo - 1;
						
						curr <= std_logic_vector(unsigned(curr) + 1);
					 
					--pull low
					elsif(numPeriodsToDo > 0) and (numPulsesToDo = 0) then
						numPeriodsToDo := numPeriodsToDo - 1;
						
						en_a <= '0';
						en_b <= '0';
						
					--end of cycle
					elsif(numPeriodsToDo = 0) and (numPulsesToDo = 0) then
						required <= std_logic_vector(unsigned(required) - 1);
						numPeriodsToDo := 31250;
						numPulsesToDo := 28125;

						
						
						
					end if;
				--end loop;
			--	wait;
			end if;
		end process;
		


end architecture rtl; -- of new_component
