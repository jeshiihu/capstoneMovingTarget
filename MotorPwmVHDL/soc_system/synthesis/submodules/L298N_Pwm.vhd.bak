-- L298N_Pwm.vhd

-- This file was auto-generated as a prototype implementation of a module
-- created in component editor.  It ties off all outputs to ground and
-- ignores all inputs.  It needs to be edited to make it do something
-- useful.
-- 
-- This file will not be automatically regenerated.  You should check it in
-- to your version control system if you want to keep it.

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity L298N_Pwm is
	port (
		reset_n        : in  std_logic                     := '0';             --       reset.reset_n
		clk            : in  std_logic                     := '0';             --       clock.clk
		a              : out std_logic;                                        -- conduit_end.a
		b              : out std_logic;                                        --            .b
		a_comp         : out std_logic;                                        --            .a_comp
		b_comp         : out std_logic;                                        --            .b_comp
		en_a           : out std_logic;                                        --            .en_a
		en_b           : out std_logic;                                        --            .en_b
		step_write_n   : in  std_logic                     := '0';             --        step.write_n
		step_writedata : in  std_logic_vector(15 downto 0) := (others => '0'); --            .writedata
		step_read_n    : in  std_logic                     := '0';             --            .read_n
		step_readdata  : out std_logic_vector(15 downto 0)                     --            .readdata
	);
end entity L298N_Pwm;

architecture rtl of L298N_Pwm is
	procedure get_step (
	signal currentStep : in std_logic_vector(1 downto 0);
	
	-- full step Cw direction, A(Brown) A#(Red) B(Green) B#(White) 
	constant fs_one 	 : std_logic_vector (3 downto 0)   := b"1010";
	constant fs_two 	 : std_logic_vector (3 downto 0)   := b"1001";
	constant fs_three  : std_logic_vector (3 downto 0)   := b"0101";
	constant fs_four 	 : std_logic_vector (3 downto 0)   := b"0110";	
		
	signal four_coils : out std_logic_vector (3 downto 0) 
	)is
	begin	
		case currentStep is -- translate two bits to step sequence
			when b"00" => four_coils <= fs_one;
			when b"01" => four_coils <= fs_two;
			when b"10" => four_coils <= fs_three;
			when b"11" => four_coils <= fs_four;
		end case;
	end get_step;
	
	-- Signals used in the pwm process
	signal currStep 		: std_logic_vector(1 downto 0) := "00";
	signal numSteps 		: std_logic_vector(15 downto 0) := (others => '0');
	signal output_coils  : std_logic_vector(3 downto 0) ;
	
begin
	write_to_hBridge:
	process(clk, reset_n,step_write_n) is		
-- 1600Hz or 1600PPS for 0.7kg load (75.68mHm) at FULL STEP 
		constant period   : integer := 500000;
		constant highDuty : integer := 450000; -- 90%
		constant lowDuty  : integer := 250000; --50%

		variable numPeriodsToDo: integer := period; 
		variable numPulsesToDo : integer := highDuty;
			
		begin
			if(reset_n = '0') then
				step_readdata <= "00000000000000000000000000000000";
				en_a <= '0';
				en_b <= '0';
			elsif(step_write_n = '0') then
				numSteps <= step_writedata;
				step_readdata <= step_writedata;	
			elsif rising_edge(clk) and (unsigned(numSteps) /= 0) then
				-- PWM signal pulled high
				if(numPeriodsToDo > 0) and (numPulsesToDo > 0) then
					numPeriodsToDo := numPeriodsToDo - 1;
					numPulsesToDo  := numPulsesToDo - 1;
					
					get_step(currStep, four_coils => output_coils ); 
					a 		 <= output_coils(3);
					a_comp <= output_coils(2);
					b 		 <= output_coils(1);
					b_comp <= output_coils(0);
					en_a   <= '1';
					en_b   <= '1';
				-- PWM signal pulled low
				elsif(numPeriodsToDo > 0) and (numPulsesToDo = 0) then
					numPeriodsToDo := numPeriodsToDo - 1;
					
					get_step(currStep, four_coils => output_coils );
					a 		 <= output_coils(3);
					a_comp <= output_coils(2);
					b 		 <= output_coils(1);
					b_comp <= output_coils(0);
					en_a   <= '0';
					en_b   <= '0';
				--end of cycle
				elsif(numPeriodsToDo = 0) and (numPulsesToDo = 0) then
					numSteps <= std_logic_vector(unsigned(numSteps) - 1);
					currStep <= std_logic_vector(unsigned(currStep) + 1);
					numPeriodsToDo := period;
					numPulsesToDo  := highDuty;
				else 
					en_a <= '0';
					en_b <= '0';
				end if;
			end if;
		end process;

end architecture rtl; -- of L298N_Pwm
